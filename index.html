<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SQL Injection - Comprehensive Guide</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Segoe+UI:wght@300;400;600;700&family=Fira+Code:wght@400;500;600&display=swap" rel="stylesheet">
    <style>
        /* General styles */
        body {
            font-family: 'Segoe UI', sans-serif;
            margin: 0;
            padding: 0;
            /* Your requested background image styles */
            background-image: url('https://m.media-amazon.com/images/M/MV5BNWU5Zjk4NDUtMjEzNy00MmEzLThhNGUtOTJiNzRjN2RmNmU5XkEyXkFqcGc@._V1_.jpg');
            background-size: cover; /* Cover the entire viewport */
            background-position: center; /* Center the background image */
            background-repeat: no-repeat; /* Do not repeat the image */
            background-attachment: fixed; /* Keep image fixed when scrolling */
            color: #333;
            line-height: 1.6;
            min-height: 100vh; /* Ensure body takes full height for fixed background to work */
            display: flex; /* Use flex to stretch the overlay */
            flex-direction: column; /* Stack content vertically */
        }

        /* Overlay for better text readability */
        .overlay {
            position: absolute; /* Position over the background image */
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(255, 255, 255, 0.8); /* Semi-transparent white overlay */
            z-index: -1; /* Place it behind the content */
        }

        .container {
            max-width: 900px;
            margin: 40px auto;
            padding: 20px;
            background-color: #ffffff; /* Explicitly set container background to opaque white */
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            border-radius: 12px;
            position: relative; /* Ensure container content is above the overlay */
            z-index: 1; /* Bring container above the overlay */
        }

        .section {
            padding: 40px 20px;
            margin-bottom: 30px;
            border-bottom: 1px solid #eee;
            text-align: center;
        }

        .section:last-child {
            border-bottom: none;
            margin-bottom: 0;
        }

        h1 {
            color: #e74c3c;
            text-align: center;
            font-size: 3em;
            margin-bottom: 40px;
            padding-bottom: 15px;
            border-bottom: 3px solid #e74c3c;
        }

        h2 {
            color: #e74c3c;
            border-bottom: 2px solid #e74c3c;
            padding-bottom: 10px;
            margin-bottom: 30px;
            font-size: 2.2em;
            text-align: center;
        }

        h3 {
            color: #e74c3c;
            font-size: 1.5em;
            margin-top: 30px;
            margin-bottom: 15px;
            text-align: center;
        }

        p {
            color: #333;
            font-size: 1.1em;
            line-height: 1.5;
            margin-bottom: 15px;
            max-width: 800px;
            margin-left: auto;
            margin-right: auto;
        }

        /* Code specific styles */
        pre {
            background: #2d2d2d; /* Darker background for code */
            color: #f8f8f2; /* Light text for code */
            padding: 15px;
            border-radius: 8px;
            font-size: 0.95em;
            overflow-x: auto; /* Allow horizontal scrolling for code blocks */
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            text-align: left;
            margin: 20px auto;
            max-width: 80%;
            font-family: 'Fira Code', 'Consolas', monospace;
        }
        code {
            font-family: 'Fira Code', 'Consolas', monospace;
            color: #66d9ef; /* Cyan for general inline code */
        }
        pre code {
            color: #f8f8f2; /* Ensure code inside pre is light */
        }
        pre code .comment {
            color: #75715e; /* Grey for comments */
        }
        pre code .keyword {
            color: #f92672; /* Pink for keywords */
        }
        pre code .string {
            color: #e6db74; /* Yellow for strings */
        }
        pre code .variable {
            color: #a6e22e; /* Green for variables */
        }

        /* List styles */
        ul {
            list-style-type: none;
            padding: 0;
            text-align: left;
            margin: 30px auto;
            max-width: 70%;
        }
        ul li {
            margin-bottom: 10px;
            font-size: 1.1em;
            color: #333;
            position: relative;
            padding-left: 25px;
        }
        ul li:before {
            content: "•"; /* Custom bullet point */
            color: #2ecc71; /* Green bullet */
            position: absolute;
            left: 0;
            font-size: 1.2em;
            top: 0;
        }

        /* Exercise specific styles */
        .exercise-container {
            margin-top: 30px;
            padding: 25px;
            border: 1px solid #c0392b; /* Darker red border */
            border-radius: 10px;
            background-color: #fff3f2; /* Light red background */
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
            text-align: left;
            max-width: 70%;
            margin-left: auto;
            margin-right: auto;
        }
        .exercise-container h3 {
            color: #c0392b;
            margin-top: 0;
            font-size: 1.8em;
            text-align: center;
        }
        .exercise-container p {
            text-align: center;
        }
        .exercise-container label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            color: #555;
        }
        .exercise-container input[type="text"] {
            width: calc(100% - 20px);
            padding: 10px;
            margin-bottom: 15px;
            border: 1px solid #e74c3c;
            border-radius: 5px;
            font-size: 1em;
            box-sizing: border-box; /* Include padding in width */
        }
        .exercise-container button {
            padding: 12px 25px;
            background-color: #e74c3c; /* Red button */
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1.1em;
            transition: background-color 0.3s ease;
            display: block;
            margin: 10px auto; /* Center buttons */
        }
        .exercise-container button:hover {
            background-color: #c0392b; /* Darker red on hover */
        }
        .solution-box {
            margin-top: 20px;
            padding: 15px;
            border: 1px solid #28a745; /* Green border for solution */
            background-color: #d4edda; /* Light green background */
            color: #155724; /* Dark green text */
            border-radius: 5px;
            display: none; /* Hidden by default */
            text-align: left;
        }
        .solution-box h4 {
            color: #155724;
            margin-top: 0;
        }
        .solution-box ul {
            list-style-type: disc;
            margin-left: 20px;
            max-width: 100%; /* Adjust for nested list */
        }
        .solution-box ul li {
            padding-left: 0;
        }
        .solution-box ul li:before {
            content: none;
        }

        /* Specific highlights */
        .php-note {
            background-color: #fdf5e6; /* Light yellow background */
            border-left: 5px solid #ffcc00; /* Yellow border */
            padding: 15px;
            margin-top: 20px;
            border-radius: 5px;
            font-style: italic;
            color: #333;
            max-width: 800px;
            margin-left: auto;
            margin-right: auto;
            text-align: left;
        }

        /* Data table styles */
        .data-table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px auto;
            max-width: 600px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        .data-table th, .data-table td {
            border: 1px solid #ddd;
            padding: 10px;
            text-align: left;
        }
        .data-table th {
            background-color: #e74c3c;
            color: white;
            font-weight: bold;
        }
        .data-table tr:nth-child(even) {
            background-color: #f2f2f2;
        }
        .data-table tr:hover {
            background-color: #e0e0e0;
        }

        /* Output section style */
        .output-box {
            background: #f0f8ff; /* Light blue background for output */
            border: 1px dashed #a0d6ff;
            padding: 15px;
            margin: 20px auto;
            border-radius: 8px;
            max-width: 80%;
            text-align: left;
            font-family: 'Fira Code', monospace;
            font-size: 0.9em;
            color: #004085;
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.05);
        }
        .output-box strong {
            color: #002752;
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            .container {
                margin: 20px auto;
                padding: 15px;
            }
            h1 {
                font-size: 2.5em;
            }
            h2 {
                font-size: 1.8em;
            }
            p, ul li, .exercise-container p, .exercise-container label, .exercise-container input, .exercise-container button, .php-note {
                font-size: 1em;
            }
            .exercise-container, pre, .php-note, .data-table, .output-box {
                max-width: 95%;
                margin-left: auto;
                margin-right: auto;
            }
            .data-table thead {
                display: none; /* Hide table headers on small screens */
            }
            .data-table, .data-table tbody, .data-table tr, .data-table td {
                display: block; /* Make table elements stack */
            }
            .data-table tr {
                margin-bottom: 10px;
                border: 1px solid #ddd;
                border-radius: 5px;
            }
            .data-table td {
                text-align: right;
                padding-left: 50%;
                position: relative;
            }
            .data-table td::before {
                content: attr(data-label);
                position: absolute;
                left: 6px;
                width: 45%;
                padding-right: 10px;
                white-space: nowrap;
                text-align: left;
                font-weight: bold;
            }
        }
    </style>
</head>
<body>
    <!-- Overlay for background image text readability -->
    <div class="overlay"></div>

    <div class="container">
    <h1>SQL Injection: Hiểu và Phòng Chống</h1>

    <div class="section">
        <h2>SQL Injection là gì?</h2>
        <p>
            SQL Injection (SQLi) là một kỹ thuật tấn công chèn mã vào ứng dụng, nơi kẻ xấu chèn các câu lệnh SQL độc hại vào ô nhập liệu để thực thi (ví dụ: lấy toàn bộ dữ liệu từ database).
        </p>
        <p>
            Nói đơn giản, SQLi cho phép kẻ tấn công điều khiển các câu lệnh gửi đến database. Điều này giúp họ truy cập, sửa đổi dữ liệu trái phép, hoặc thậm chí chiếm quyền kiểm soát toàn bộ hệ thống. Giống như việc bạn đang "nói chuyện" với database bằng ngôn ngữ của nó, nhưng lại nói những điều mà nó không được phép nghe hay làm theo.
        </p>
    </div>

    <div class="section">
        <h2>SQLi hoạt động thế nào: Lỗ hổng dễ bị tấn công</h2>
        <p>
            SQLi xảy ra khi một ứng dụng tạo câu lệnh SQL bằng cách ghép trực tiếp dữ liệu do người dùng nhập vào chuỗi truy vấn, mà không làm sạch (sanitization) hoặc dùng tham số hóa (parameterization) đúng cách.
        </p>
        <p>
            Điều này cho phép kẻ tấn công thay đổi ý nghĩa của câu lệnh gốc bằng cách chèn các lệnh độc hại vào phần nhập liệu của họ.
        </p>
        <pre><code><span class="comment">// Ví dụ về một câu truy vấn PHP dễ bị tấn công</span>
<span class="variable">$category</span> = <span class="keyword">$_GET</span>[<span class="string">'category'</span>]; <span class="comment">// Dữ liệu người dùng nhập trực tiếp!</span>
<span class="variable">$sql</span> = <span class="string">"SELECT * FROM products WHERE category = '"</span> . <span class="variable">$category</span> . <span class="string">"'"</span>;
<span class="variable">$result</span> = <span class="keyword">mysqli_query</span>(<span class="variable">$conn</span>, <span class="variable">$sql</span>); <span class="comment">// Thực thi chuỗi đã ghép</span></code></pre>
        <div class="php-note">
            Trong quá khứ, các ứng dụng viết bằng ngôn ngữ như <strong>PHP</strong> rất dễ bị lỗ hổng này. Lý do chính là do thói quen phổ biến là nhúng trực tiếp dữ liệu người dùng vào chuỗi SQL bằng cách nối chuỗi, cùng với việc nhiều lập trình viên chưa nhận thức được tầm quan trọng của các câu lệnh được chuẩn bị trước (prepared statements) và xác thực dữ liệu đầu vào.
        </div>
    </div>

    <div class="section">
        <h2>Ví dụ Vượt Qua Đăng Nhập (Login Bypass)</h2>
        <p>Một kiểu tấn công SQLi kinh điển thường nhắm vào các form đăng nhập.</p>

        <h3>Dữ liệu giả định trong bảng `users`:</h3>
        <table class="data-table">
            <thead>
                <tr>
                    <th>id</th>
                    <th>username</th>
                    <th>password</th>
                    <th>role</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td data-label="id">1</td>
                    <td data-label="username">admin</td>
                    <td data-label="password">supersecretpass</td>
                    <td data-label="role">administrator</td>
                </tr>
                <tr>
                    <td data-label="id">2</td>
                    <td data-label="username">john.doe</td>
                    <td data-label="password">password123</td>
                    <td data-label="role">user</td>
                </tr>
            </tbody>
        </table>

        <p><strong>Cấu trúc câu truy vấn dễ bị lỗi:</strong></p>
        <pre><code class="language-sql"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> username = '<span class="variable">{{username_input}}</span>' <span class="keyword">AND</span> password = '<span class="variable">{{password_input}}</span>'</code></pre>

        <p><strong>Dữ liệu nhập vào độc hại:</strong></p>
        <ul>
            <li>Tên đăng nhập (Username): <code>admin'--</code></li>
            <li>Mật khẩu (Password): <code>(bất kỳ giá trị nào hoặc để trống)</code></li>
        </ul>

        <p><strong>Câu truy vấn thực tế được Database thực thi:</strong></p>
        <pre><code class="language-sql"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> username = '<span class="variable">admin</span>'<span class="comment">--' AND password = 'anything'</span></code></pre>

        <p><strong>Kết quả thực tế / Hành vi của ứng dụng:</strong></p>
        <div class="output-box">
            <strong>Kết quả:</strong>
            <pre><code>id: 1
username: admin
password: supersecretpass
role: administrator</code></pre>
            <p><strong>Hành vi của ứng dụng:</strong> Kẻ tấn công đăng nhập thành công với tài khoản 'admin' mà không cần biết mật khẩu. Điều này xảy ra vì <code>--</code> đã biến phần còn lại của câu truy vấn thành chú thích, làm cho việc kiểm tra mật khẩu trở nên vô nghĩa.</p>
        </div>
    </div>

    <div class="section">
        <h2>Rút trích dữ liệu (Data Exfiltration) (dựa trên UNION SQLi)</h2>
        <p>Kỹ thuật này sử dụng toán tử <code>UNION</code> để kết hợp kết quả từ hai hoặc nhiều câu lệnh <code>SELECT</code> thành một tập hợp kết quả duy nhất. Điều này cho phép kẻ tấn công lấy dữ liệu từ các bảng khác.</p>

        <h3>Bảng dữ liệu giả định:</h3>
        <h4>Bảng `products`:</h4>
        <table class="data-table">
            <thead>
                <tr>
                    <th>product_id</th>
                    <th>product_name</th>
                    <th>description</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td data-label="product_id">1</td>
                    <td data-label="product_name">Laptop X</td>
                    <td data-label="description">Laptop hiệu năng cao</td>
                </tr>
                <tr>
                    <td data-label="product_id">2</td>
                    <td data-label="product_name">Smartphone Y</td>
                    <td data-label="description">Thiết bị di động mới nhất</td>
                </tr>
            </tbody>
        </table>
        <h4>Bảng `users`:</h4>
        <table class="data-table">
            <thead>
                <tr>
                    <th>user_id</th>
                    <th>username</th>
                    <th>password</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td data-label="user_id">1</td>
                    <td data-label="username">alice</td>
                    <td data-label="password">pass_alice</td>
                </tr>
                <tr>
                    <td data-label="user_id">2</td>
                    <td data-label="username">bob</td>
                    <td data-label="password">pass_bob</td>
                </tr>
            </tbody>
        </table>

        <p><strong>Cấu trúc câu truy vấn dễ bị lỗi (ví dụ: lấy chi tiết sản phẩm theo ID):</strong></p>
        <pre><code class="language-sql"><span class="keyword">SELECT</span> product_name, description <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> product_id = <span class="variable">{{product_id_input}}</span></code></pre>

        <p><strong>Dữ liệu nhập vào độc hại cho `product_id_input`:</strong></p>
        <ul>
            <li><code>-1 UNION SELECT username, password FROM users--</code></li>
        </ul>
        <p class="comment">(Sử dụng <code>-1</code> để đảm bảo không có sản phẩm hợp lệ nào được trả về, chỉ tập trung vào phần UNION. Lưu ý: Số lượng cột và kiểu dữ liệu của chúng phải khớp nhau. Ở đây, `username` khớp với `product_name` và `password` khớp với `description`.)</p>

        <p><strong>Câu truy vấn thực tế được Database thực thi:</strong></p>
        <pre><code class="language-sql"><span class="keyword">SELECT</span> product_name, description <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> product_id = <span class="variable">-1</span> <span class="keyword">UNION</span> <span class="keyword">SELECT</span> username, password <span class="keyword">FROM</span> users<span class="comment">--</span></code></pre>

        <p><strong>Kết quả thực tế / Hành vi của ứng dụng:</strong></p>
        <div class="output-box">
            <strong>Kết quả (hiển thị cho người dùng nếu ứng dụng chỉ in kết quả truy vấn):</strong>
            <pre><code>product_name | description
----------------------------
alice        | pass_alice
bob          | pass_bob</code></pre>
            <p><strong>Hành vi của ứng dụng:</strong> Ứng dụng, thường hiển thị chi tiết sản phẩm, giờ đây lại hiển thị tên người dùng và mật khẩu từ bảng `users`. Đây là một lỗ hổng rò rỉ dữ liệu trực tiếp.</p>
        </div>
    </div>

    <div class="section">
        <h2>SQLi Dựa trên Lỗi (Error-based SQLi)</h2>
        <p>
            Kỹ thuật này buộc database báo lỗi và lỗi đó chứa thông tin nhạy cảm, như phiên bản database, tên bảng, hoặc tên cột. Kẻ tấn công tạo ra các lỗi này bằng cách chèn các câu lệnh SQL sai cú pháp.
        </p>

        <h3>Bảng `products` giả định (giống như trên):</h3>
        <table class="data-table">
            <thead>
                <tr>
                    <th>product_id</th>
                    <th>product_name</th>
                    <th>description</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td data-label="product_id">1</td>
                    <td data-label="product_name">Laptop X</td>
                    <td data-label="description">Laptop hiệu năng cao</td>
                </tr>
            </tbody>
        </table>

        <p><strong>Cấu trúc câu truy vấn dễ bị lỗi (ví dụ: lấy chi tiết sản phẩm theo ID):</strong></p>
        <pre><code class="language-sql"><span class="keyword">SELECT</span> product_name <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> product_id = <span class="variable">{{product_id_input}}</span></code></pre>

        <p><strong>Dữ liệu nhập vào độc hại cho `product_id_input` (Ví dụ MySQL):</strong></p>
        <ul>
            <li><code>1 AND (SELECT 1 FROM (SELECT COUNT(*), CONCAT(VERSION(), FLOOR(RAND(0)*2))x FROM INFORMATION_SCHEMA.TABLES GROUP BY x)a)--</code></li>
        </ul>
        <p class="comment">(Payload này cố gắng tạo lỗi khóa trùng lặp bằng cách sử dụng `FLOOR(RAND(0)*2)` và ghép thông tin `VERSION()` vào để kích hoạt thông báo lỗi chứa dữ liệu nhạy cảm.)</p>

        <p><strong>Câu truy vấn thực tế được Database thực thi:</strong></p>
        <pre><code class="language-sql"><span class="keyword">SELECT</span> product_name <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> product_id = 1 <span class="keyword">AND</span> (<span class="keyword">SELECT</span> 1 <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*), <span class="keyword">CONCAT</span>(<span class="keyword">VERSION</span>(), <span class="keyword">FLOOR</span>(<span class="keyword">RAND</span>(0)*2))x <span class="keyword">FROM</span> <span class="keyword">INFORMATION_SCHEMA.TABLES</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span> x)a)<span class="comment">--</span></code></pre>

        <p><strong>Kết quả thực tế / Hành vi của ứng dụng:</strong></p>
        <div class="output-box">
            <strong>Kết quả (Thông báo lỗi Database hiển thị cho người dùng):</strong>
            <pre><code>SQLSTATE[23000]: Integrity constraint violation: 1062 Duplicate entry '5.7.23-log1' for key 'group_key'</code></pre>
            <p><strong>Hành vi của ứng dụng:</strong> Ứng dụng, thay vì hiển thị chi tiết sản phẩm, lại hiển thị một thông báo lỗi database làm lộ phiên bản database (`5.7.23-log`). Kẻ tấn công có thể tạo ra các payload tương tự để rút trích các thông tin khác (ví dụ: tên bảng, tên cột).</p>
        </div>
    </div>

    <div class="section">
        <h2>SQL Injection Ẩn (Blind SQL Injection) (Dựa trên Boolean)</h2>
        <p>
            Khác với SQLi kiểu "in-band" (trả về dữ liệu trực tiếp), Blind SQLi không trả về dữ liệu trực tiếp. Thay vào đó, kẻ tấn công suy luận dữ liệu bằng cách quan sát những khác biệt nhỏ trong hành vi của ứng dụng (ví dụ: nội dung trang thay đổi, chuyển hướng) dựa trên các điều kiện đúng/sai được chèn vào câu truy vấn.
        </p>

        <h3>Dữ liệu giả định trong bảng `users` (giống như trên):</h3>
        <table class="data-table">
            <thead>
                <tr>
                    <th>id</th>
                    <th>username</th>
                    <th>password</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td data-label="id">1</td>
                    <td data-label="username">admin</td>
                    <td data-label="password">secret123</td>
                </tr>
            </tbody>
        </table>

        <p><strong>Cấu trúc câu truy vấn dễ bị lỗi (ví dụ: kiểm tra người dùng có tồn tại không):</strong></p>
        <pre><code class="language-sql"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> id = <span class="variable">{{id_input}}</span></code></pre>

        <p><strong>Dữ liệu nhập vào độc hại cho `id_input` (Cố gắng đoán mật khẩu cho `id=1`):</strong></p>
        <ul>
            <li>Thử 1 (Đoán 's'): <code>1 AND SUBSTRING(password, 1, 1) = 's'--</code></li>
            <li>Thử 2 (Đoán 'x'): <code>1 AND SUBSTRING(password, 1, 1) = 'x'--</code></li>
        </ul>

        <p><strong>Câu truy vấn thực tế được Database thực thi:</strong></p>
        <pre><code class="language-sql">-- Thử 1
<span class="keyword">SELECT</span> * <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> id = 1 <span class="keyword">AND</span> <span class="keyword">SUBSTRING</span>(password, 1, 1) = 's'<span class="comment">--</span>

-- Thử 2
<span class="keyword">SELECT</span> * <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> id = 1 <span class="keyword">AND</span> <span class="keyword">SUBSTRING</span>(password, 1, 1) = 'x'<span class="comment">--</span></code></pre>

        <p><strong>Kết quả thực tế / Hành vi của ứng dụng:</strong></p>
        <div class="output-box">
            <strong>Hành vi của ứng dụng với Thử 1 (mật khẩu bắt đầu bằng 's'):</strong>
            <p>Trang tải bình thường, có thể hiển thị thông báo "Tìm thấy người dùng" hoặc nội dung mặc định cho người dùng hiện có.</p>
            <strong>Hành vi của ứng dụng với Thử 2 (mật khẩu KHÔNG bắt đầu bằng 'x'):</strong>
            <p>Trang hiển thị thông báo "ID không hợp lệ" hoặc "Không tìm thấy người dùng", hoặc có thể là một trang trống/chuyển hướng đến trang lỗi.</p>
            <p><strong>Giải thích:</strong> Bằng cách quan sát những hành vi khác nhau này, kẻ tấn công có thể xác nhận rằng ký tự đầu tiên của mật khẩu là 's'. Họ lặp lại quá trình này cho từng ký tự và vị trí để xây dựng lại toàn bộ mật khẩu.</p>
        </div>
    </div>

    <div class="section">
        <h2>SQL Injection Ẩn (Blind SQL Injection) (Dựa trên Thời gian)</h2>
        <p>
            Đây là một dạng nâng cao của Blind SQLi, được dùng khi không có lỗi hoặc sự khác biệt nội dung nào khác có thể quan sát được. Kẻ tấn công suy luận dữ liệu bằng cách gây ra một độ trễ thời gian có thể đo lường được trong phản hồi của database nếu một điều kiện cụ thể là đúng.
        </p>

        <h3>Dữ liệu giả định trong bảng `users` (giống như trên):</h3>
        <table class="data-table">
            <thead>
                <tr>
                    <th>id</th>
                    <th>username</th>
                    <th>password</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td data-label="id">1</td>
                    <td data-label="username">admin</td>
                    <td data-label="password">secret123</td>
                </tr>
            </tbody>
        </table>

        <p><strong>Cấu trúc câu truy vấn dễ bị lỗi (ví dụ: kiểm tra người dùng có tồn tại không):</strong></p>
        <pre><code class="language-sql"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> id = <span class="variable">{{id_input}}</span></code></pre>

        <p><strong>Dữ liệu nhập vào độc hại cho `id_input` (Cố gắng đoán mật khẩu cho `id=1`):</strong></p>
        <ul>
            <li>Thử 1 (Đoán 's'): <code>1 AND IF(SUBSTRING(password, 1, 1) = 's', SLEEP(5), 0)--</code></li>
            <li>Thử 2 (Đoán 'x'): <code>1 AND IF(SUBSTRING(password, 1, 1) = 'x', SLEEP(5), 0)--</code></li>
        </ul>

        <p><strong>Câu truy vấn thực tế được Database thực thi:</strong></p>
        <pre><code class="language-sql">-- Thử 1
<span class="keyword">SELECT</span> * <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> id = 1 <span class="keyword">AND</span> <span class="keyword">IF</span>(<span class="keyword">SUBSTRING</span>(password, 1, 1) = 's', <span class="keyword">SLEEP</span>(5), 0)<span class="comment">--</span>

-- Thử 2
<span class="keyword">SELECT</span> * <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> id = 1 <span class="keyword">AND</span> <span class="keyword">IF</span>(<span class="keyword">SUBSTRING</span>(password, 1, 1) = 'x', <span class="keyword">SLEEP</span>(5), 0)<span class="comment">--</span></code></pre>

        <p><strong>Kết quả thực tế / Hành vi của ứng dụng:</strong></p>
        <div class="output-box">
            <strong>Hành vi của ứng dụng với Thử 1 (mật khẩu bắt đầu bằng 's'):</strong>
            <p>Trang web phản hồi chậm hơn khoảng 5 giây so với bình thường.</p>
            <strong>Hành vi của ứng dụng với Thử 2 (mật khẩu KHÔNG bắt đầu bằng 'x'):</strong>
            <p>Trang web phản hồi ngay lập tức (hoặc chỉ chậm một chút).</p>
            <p><strong>Giải thích:</strong> Kẻ tấn công có thể đo chính xác thời gian phản hồi. Độ trễ 5 giây cho thấy điều kiện là đúng. Điều này xác nhận 's' là ký tự đầu tiên. Quá trình này được lặp lại để trích xuất toàn bộ mật khẩu và các dữ liệu nhạy cảm khác, mặc dù chậm.</p>
        </div>
    </div>

    <div class="section">
        <h2>Bài tập: Sửa lỗi Tìm kiếm Sản phẩm</h2>
        <p>Giá trị `search_term` được nối trực tiếp vào câu truy vấn, làm cho nó dễ bị SQL Injection. Bạn sẽ sửa đổi đoạn mã Python này như thế nào để nó an toàn?</p>
        <pre><code><span class="comment"># Đoạn mã Python dễ bị lỗi</span>
<span class="variable">search_term</span> = <span class="string">"user_input"</span>
<span class="variable">query</span> = <span class="string">"SELECT * FROM products WHERE product_name LIKE '%"</span> + <span class="variable">search_term</span> + <span class="string">"%'"</span>

<span class="comment"># Đã sửa (Ví dụ API Python DB sử dụng tham số hóa truy vấn):</span>
<span class="variable">param_value</span> = <span class="string">'%'</span> + <span class="variable">search_term</span> + <span class="string">'%'</span>
<span class="variable">query</span> = <span class="string">"SELECT * FROM products WHERE product_name LIKE ?"</span>
<span class="variable">cursor</span>.<span class="keyword">execute</span>(<span class="variable">query</span>, (<span class="variable">param_value</span>,))</code></pre>
        <p><strong>Giải pháp:</strong> Mã đã sửa sử dụng truy vấn tham số hóa (parameterized query). Điều này tách biệt mã SQL khỏi dữ liệu do người dùng cung cấp, đảm bảo database coi `param_value` là một chuỗi văn bản thông thường, chứ không phải mã có thể thực thi. Đây là biện pháp phòng thủ chính và hiệu quả nhất chống lại SQL Injection.</p>
    </div>

    <div class="section">
        <h2>Bài tập: Sửa lỗi Truy vấn ID Số nguyên</h2>
        <p>Ngay cả các trường nhập liệu dạng số nguyên cũng có thể bị khai thác nếu không được xử lý đúng cách. `article_id` được sử dụng trực tiếp ở đây. Làm thế nào bạn có thể ngăn chặn SQL Injection?</p>
        <pre><code><span class="comment"># Đoạn mã Python dễ bị lỗi</span>
<span class="variable">article_id</span> = <span class="string">"user_input"</span> <span class="comment">// Có thể là "1 OR 1=1"</span>
<span class="variable">query</span> = <span class="string">"SELECT * FROM articles WHERE id = "</span> + <span class="variable">article_id</span>

<span class="comment"># Đã sửa (Ví dụ API Python DB sử dụng tham số hóa truy vấn):</span>
<span class="variable">query</span> = <span class="string">"SELECT * FROM articles WHERE id = ?"</span>
<span class="variable">cursor</span>.<span class="keyword">execute</span>(<span class="variable">query</span>, (<span class="variable">article_id</span>,))</code></pre>
        <p><strong>Giải pháp:</strong> Bằng cách sử dụng truy vấn tham số hóa, driver database đảm bảo rằng `article_id` được coi là một giá trị số nguyên duy nhất, ngăn chặn bất kỳ SQL nào bị chèn vào không được thực thi. Việc xác thực dữ liệu đầu vào (ví dụ: ép kiểu sang `int`) để đảm bảo `article_id` thực sự là một số nguyên trước khi truyền nó vào truy vấn cũng là một lớp bảo vệ quan trọng, nhưng tham số hóa là biện pháp bảo vệ cuối cùng chống lại injection.</p>
    </div>

    <div class="section">
        <h2>Bài tập Tương tác: Vượt Qua Đăng Nhập</h2>
        <div class="exercise-container">
            <h3>Thử mô phỏng đăng nhập</h3>
            <p>
                Hãy thử đăng nhập với tư cách 'admin' mà không cần biết mật khẩu. Nhập 'Tên đăng nhập' và 'Mật khẩu' của bạn (hoặc chỉ một tên đăng nhập độc hại).
                Đây chỉ là mô phỏng phía client và không tương tác với hệ thống backend thật.
            </p>
            <label for="ex_username">Tên đăng nhập:</label>
            <input
                type="text"
                id="ex_username"
                placeholder="ví dụ: admin"
                autocomplete="off"
            />
            <label for="ex_password">Mật khẩu:</label>
            <input
                type="text"
                id="ex_password"
                placeholder="ví dụ: password (tùy chọn cho bypass)"
                autocomplete="off"
            />
            <button onclick="simulateLogin()">Mô phỏng Đăng nhập</button>
            <div id="loginResult" class="solution-box"></div>
            <button
                style="margin-top: 10px; background-color: #2ecc71"
                onclick="showLoginSolution()"
            >
                Hiển thị Giải pháp
            </button>
            <div id="loginSolution" class="solution-box">
                <h4>Các Giải pháp Vượt qua Phổ biến:</h4>
                <ul>
                    <li>
                        <strong>Tên đăng nhập:</strong> <code>admin'--</code>
                        <span class="comment">(Biến phần còn lại của câu truy vấn thành chú thích)</span>
                    </li>
                    <li>
                        <strong>Tên đăng nhập:</strong> <code>admin' OR '1'='1</code>
                        <span class="comment">(Điều kiện luôn đúng)</span>
                    </li>
                    <li>
                        <strong>Tên đăng nhập:</strong> <code>' OR '1'='1--</code>
                        <span class="comment">(Vượt qua cả tên đăng nhập và mật khẩu)</span>
                    </li>
                </ul>
                <p>
                    Các dữ liệu nhập vào này sẽ thao túng câu lệnh SQL để nó trả về
                    kết quả đúng, vượt qua logic xác thực ban đầu.
                </p>
            </div>
        </div>
    </div>

    <div class="section">
        <h2>Các Biện pháp Tốt Nhất: Lá chắn chống SQLi của bạn</h2>
        <ul>
            <li>
                <strong>Sử dụng Truy vấn Tham số hóa / Câu lệnh Chuẩn bị sẵn (Prepared Statements):</strong> Đây là tiêu chuẩn vàng. Chúng tách mã SQL khỏi dữ liệu người dùng, đảm bảo dữ liệu nhập vào được xử lý như các giá trị thông thường, không phải là lệnh có thể thực thi.
            </li>
            <li>
                <strong>Xác thực Kiểu và Định dạng Dữ liệu Đầu vào:</strong> Thực hiện danh sách cho phép (allow-lists hay whitelisting) nghiêm ngặt cho tất cả các dữ liệu đầu vào. Từ chối bất kỳ thứ gì không phù hợp với các định dạng mong đợi (ví dụ: chỉ số cho ID, chỉ các ký tự cụ thể cho tên).
            </li>
            <li>
                <strong>Sử dụng ORM (Object-Relational Mappers):</strong> Các framework như SQLAlchemy (Python), Hibernate (Java), và Entity Framework (.NET) cung cấp một lớp trừu tượng hóa trên SQL thô, thường tích hợp truy vấn tham số hóa theo mặc định, giảm nguy cơ lỗi do con người.
            </li>
            <li>
                <strong>Tuân thủ Nguyên tắc Quyền Hạn Tối Thiểu (Principle of Least Privilege):</strong> Chỉ cấp cho người dùng database các quyền tối thiểu cần thiết cho nhiệm vụ cụ thể của họ. Ví dụ, người dùng ứng dụng web có thể chỉ cần quyền đọc đối với một số bảng nhất định, không cần quyền DDL (Ngôn ngữ Định nghĩa Dữ liệu) hoặc DML (Ngôn ngữ Thao tác Dữ liệu) trên các bảng nhạy cảm.
            </li>
            <li>
                <strong>Sử dụng Stored Procedure một cách An toàn:</strong> Nếu sử dụng stored procedure, hãy đảm bảo chúng được thiết kế và triển khai an toàn, tức là chúng cũng sử dụng tham số hóa đầu vào bên trong và không nối trực tiếp dữ liệu người dùng.
            </li>
            <li>
                <strong>Thoát Dữ liệu Đầu vào của Người dùng (Cách cũ / Giải pháp cuối cùng):</strong> Tự thoát các ký tự đặc biệt là một phương pháp cũ và rất dễ gây lỗi. Chỉ nên sử dụng nó như một giải pháp cuối cùng trong các hệ thống cũ mà không thể tham số hóa. Luôn ưu tiên các truy vấn tham số hóa.
            </li>
            <li>
                <strong>Triển khai Tường lửa Ứng dụng Web (WAF):</strong> WAF có thể phát hiện và chặn các kiểu tấn công SQLi phổ biến ở rìa mạng, cung cấp thêm một lớp phòng thủ, đặc biệt chống lại các chữ ký tấn công đã biết.
            </li>
            <li>
                <strong>Thực hiện Kiểm tra và Đánh giá An ninh Định kỳ:</strong> Định kỳ thực hiện đánh giá bảo mật, kiểm thử xâm nhập (penetration test) và xem xét mã để xác định và khắc phục các lỗ hổng SQLi tiềm ẩn trước khi kẻ tấn công có thể khai thác chúng.
            </li>
        </ul>
    </div>

    <div class="section">
        <h2>Lời khuyên cuối cùng: Luôn An toàn!</h2>
        <p>
            <strong>Luôn coi dữ liệu người dùng là không đáng tin cậy, bất kể nguồn gốc của nó (ngay cả người dùng đã xác thực hoặc hệ thống nội bộ).</strong> Đừng bao giờ cho rằng dữ liệu đầu vào là an toàn.
        </p>
        <p>
            Áp dụng các phương pháp phát triển hiện đại như tham số hóa và ORM để xây dựng các ứng dụng mạnh mẽ và an toàn ngay từ đầu.
        </p>
        <p>
            Thường xuyên quét và kiểm tra ứng dụng của bạn để tìm lỗ hổng và luôn cập nhật các framework và thư viện của bạn để đi trước kẻ tấn công.
        </p>
        <p>Bảo mật là một quá trình liên tục, không phải là một giải pháp một lần. Cách tiếp cận chủ động là chìa khóa để chống lại SQL Injection và các lỗ hổng web khác.</p>
    </div>
</div>
    <script>
        function simulateLogin() {
            const usernameInput = document.getElementById('ex_username').value;
            const passwordInput = document.getElementById('ex_password').value;
            const loginResult = document.getElementById('loginResult');

            // Simulate a vulnerable SQL query string concatenation
            let simulatedQuery = `SELECT * FROM users WHERE username = '${usernameInput}' AND password = '${passwordInput}'`;

            let resultText = '';
            let isBypassAttempt = false;

            // Simple check for common SQLi bypass patterns
            // This is a simplified check for demonstration purposes.
            // Real-world SQLi detection is far more complex.
            if (
                usernameInput.includes("'--") || usernameInput.includes("' OR '1'='1") || usernameInput.includes("' OR 1=1") ||
                usernameInput.includes("';--") || usernameInput.includes("') OR ('1'='1")
            ) {
                isBypassAttempt = true;
            }
            if (
                passwordInput.includes("'--") || passwordInput.includes("' OR '1'='1") || passwordInput.includes("' OR 1=1") ||
                passwordInput.includes("';--") || passwordInput.includes("') OR ('1'='1")
            ) {
                isBypassAttempt = true;
            }

            if (isBypassAttempt) {
                loginResult.style.backgroundColor = '#d4edda'; // Green for success/detection
                loginResult.style.borderColor = '#28a745';
                loginResult.style.color = '#155724';
                resultText = "<p><strong>Potential SQL Injection Detected!</strong></p>";
                resultText += "<p>Simulated Query:</p>";
                resultText += `<pre><code class="language-sql">${simulatedQuery}</code></pre>`;
                resultText += "<p>If this were a real vulnerable system, you might have bypassed login!</p>";
            } else {
                loginResult.style.backgroundColor = '#fff3f2'; // Light red for no immediate detection
                loginResult.style.borderColor = '#e74c3c';
                loginResult.style.color = '#c0392b';
                resultText = "<p>Simulated Query:</p>";
                resultText += `<pre><code class="language-sql">${simulatedQuery}</code></code` + `></pre>`;
                resultText += "<p>No immediate bypass detected with this input. Keep trying common SQLi payloads!</p>";
            }
            
            loginResult.innerHTML = resultText;
            loginResult.style.display = 'block';
        }

        function showLoginSolution() {
            const solutionBox = document.getElementById('loginSolution');
            // Toggle visibility
            if (solutionBox.style.display === 'block') {
                solutionBox.style.display = 'none';
            } else {
                solutionBox.style.display = 'block';
            }
        }
    </script>
</body>
</html>
